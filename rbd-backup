#!/usr/bin/ruby
require 'json'
require 'optparse'
require __dir__ + '/lib/color.rb'

## number of snapshots to keep in cluster (0 = delete snapshots after backup)
SNAP_KEEP = 0
## number of exported snapshots to keep in BACKUP_DIR (0 = delete files after backup)
LOCAL_KEEP = 0
## where to export snapshots
BACKUP_DIR = "/home/"
## send snapshots to Tivoli
USE_DSMC = true

options = {}
OptionParser.new do |opts|
	opts.banner = "Usage: rbd-backup [options] pool [image]"

	opts.on("-c", "--config", "Use this configuration file instead of the default") do |c|
		options[:config] = ARGV[0]
	end
	opts.on("-n", "--name", "Client name for authentication") do |n|
		options[:name] = ARGV[0]
	end
end.parse!

ARGV.each do |arg|
        ARGV.delete(arg) if options.values.include? arg
end

options[:backup_pool] = ARGV[0]
options[:backup_image] = ARGV[1]

ceph_args = ""
ceph_args = "#{ceph_args} -c #{options[:config]}"	if options[:config] != nil
ceph_args = "#{ceph_args} --name #{options[:name]}"	if options[:name] != nil
images = Hash[]

begin
	pool_exist = `rados #{ceph_args} lspools | grep -c #{options[:backup_pool]} 2>/dev/null`
	if pool_exist.to_i == 0
		puts "no pool with name #{options[:backup_pool]}"
		exit
	end
rescue Exception => e
	puts "Error while get ceph pools: #{e}"
	exit
end

begin
	rbd_images = `rbd #{ceph_args} --format json ls -l #{options[:backup_pool]} 2>/dev/null`
	rbd_images = JSON.parse(rbd_images)
rescue Exception => e
	puts "Error parsing 'ceph ls -l' output: #{e}"
	exit
end

rbd_images.each do |rbd_image|
	image_uuid = rbd_image["image"]
	next if image_uuid != options[:backup_image] && options[:backup_image] != nil

	if images[image_uuid] == nil
		## create new hash entry
		images[image_uuid] = Array.new
	end

	## current image has no snapshots
	next if rbd_image["snapshot"] == nil

	if rbd_image["snapshot"] =~ /BKP_([0-9]+\.){2}[0-9]+/
		## found old snapshot
		images[image_uuid].push(rbd_image["snapshot"])
	end
end

if images.length == 0
	if options[:backup_image] != nil
		puts "no image with name #{options[:backup_image]} found"
	else
		puts "no images in pool #{options[:backup_pool]} found" if options[:backup_image]
	end
	exit
end

def doExport(image)
	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	snap_path = "vms/#{image}@#{snap_name}"

	#puts "rbd snap create #{snap_path}"
	#puts "[#{act_export_threads}/#{max_export_threads}] rbd export #{snap_path} #{BACKUP_DIR}/#{image}@#{snap_name}"
	sleep 20
end

def doArchive(image)
	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	#puts "[#{act_dsm_threads}/#{max_dsm_threads}] dsmc backup -subdir=yes #{BACKUP_DIR}/#{image}@#{snap_name}"
	sleep 120
end

threads = []
to_archive = []
max_export_threads = 1
max_dsm_threads = 5
act_export_threads = 0
act_dsm_threads = 0

images.each do |image, snaps|
	snaps.sort!.reverse!

	## rotate snapshots in cluster
	while snaps.count >= SNAP_KEEP && snaps.count != 0
		puts "rbd rm #{snaps[snaps.count-1]}"
		snaps.delete_at(snaps.count-1)
	end

	threads << Thread.new do
		sleep 1 while act_export_threads >= max_export_threads
		act_export_threads += 1

		puts "[#{act_export_threads}/#{max_export_threads}] => EXPORT: #{image}"
		doExport(image)
		act_export_threads -= 1
		to_archive.push(image) if USE_DSMC
	end

	sleep 1 while to_archive.empty?

	threads << Thread.new do
		sleep 1 while act_dsm_threads >= max_dsm_threads
		act_dsm_threads += 1

		puts "[#{act_dsm_threads}/#{max_dsm_threads}] => ARCHIVE: #{image}"
		doArchive(to_archive.shift)
		act_dsm_threads -= 1
	end

	## remove latest snapshot if KEEP == 0
#	if SNAP_KEEP == 0
#		puts "rbd snap rm #{snap_path}"
#	end

	## remove local snapshot
#	if LOCAL_KEEP == 0
#		puts "rm -f #{BACKUP_DIR}/#{image}@#{snap_name}"
#	end
end

threads.each {|thr| thr.join}
