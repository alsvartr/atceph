#!/usr/bin/ruby
require 'json'
require 'optparse'
require 'open3'
require __dir__ + '/lib/color.rb'
require __dir__ + '/lib/shout.rb'

## number of snapshots to keep in cluster (0 = delete snapshots after backup)
SNAP_KEEP = 0
## number of exported snapshots to keep in EXPORT_DIR (0 = delete files after backup)
LOCAL_KEEP = 0
## where to export snapshots
EXPORT_DIR = "/mnt/backup/"
## archive command 
ARCH_CMD = "dsmc backup -subdir=yes"
LOCK_FILE = "/tmp/rbd-backup.lock"
THREADS = Hash[:max_export => 1, :max_archive => 5]


if File.exists? LOCK_FILE
        pid = File.read(LOCK_FILE)
        if File.exists? "/proc/#{pid}/status"
                shout("already running, exit", "ERR")
                exit
        end
end
File.write(LOCK_FILE, Process.pid)


options = {}
OptionParser.new do |opts|
	opts.banner = "Usage: rbd-backup [options] pool [image]"

	opts.on("-c", "--config", "Use this configuration file instead of the default") do |c|
		options[:config] = ARGV[0]
	end
	opts.on("-n", "--name", "Client name for authentication") do |n|
		options[:name] = ARGV[0]
	end
end.parse!

ARGV.each do |arg|
        ARGV.delete(arg) if options.values.include? arg
end

options[:backup_pool] = ARGV[0]
options[:backup_image] = ARGV[1]

ceph_args = ""
ceph_args = "#{ceph_args} -c #{options[:config]}"	if options[:config] != nil
ceph_args = "#{ceph_args} --name #{options[:name]}"	if options[:name] != nil
images = Hash[]

begin
	pool_exist = `rados #{ceph_args} lspools | grep -c #{options[:backup_pool]} 2>/dev/null`
	if pool_exist.to_i == 0
		shout( "no pool with name #{options[:backup_pool]}", "ERR" )
		exit
	end
rescue Exception => e
	shout( "Error while get ceph pools: #{e}", "ERR" )
	exit
end

begin
	rbd_images = `rbd #{ceph_args} --format json ls -l #{options[:backup_pool]} 2>/dev/null`
	rbd_images = JSON.parse(rbd_images)
rescue Exception => e
	shout( "Error parsing 'ceph ls -l' output: #{e}", "ERR" )
	exit
end

rbd_images.each do |rbd_image|
	image_uuid = rbd_image["image"]
	next if image_uuid != options[:backup_image] && options[:backup_image] != nil

	if images[image_uuid] == nil
		## create new hash entry
		images[image_uuid] = Array.new
	end

	## current image has no snapshots
	next if rbd_image["snapshot"] == nil

	if rbd_image["snapshot"] =~ /BKP_([0-9]+\.){2}[0-9]+/
		## found old snapshot
		images[image_uuid].push(rbd_image["snapshot"])
	end
end

if images.length == 0
	if options[:backup_image] != nil
		shout( "no image with name #{options[:backup_image]} found", "ERR" )
	else
		shout( "no images in pool #{options[:backup_pool]} found", "ERR" ) if options[:backup_image]
	end
	exit
end

def doExport(pool, image, ceph_args)
	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	snap_path = "#{pool}/#{image}@#{snap_name}"

	`rbd #{ceph_args} snap create #{snap_path}`
	`rbd #{ceph_args} export #{snap_path} #{EXPORT_DIR}/#{image}@#{snap_name}`
	return snap_name
end

def doArchive(snap_file)
	Open3.popen3("#{ARCH_CMD} #{EXPORT_DIR}/#{snap_file}") {|i,o,e,t|
		if not t.value.success?
			shout( "Archive function error: #{e.read}", "ERR" )
		end
	}
end


threads = []
queue = Hash[:export => Array.new, :archive => Array.new]
THREADS[:act_export] = 0
THREADS[:act_archive] = 0

images.each do |image, snaps|
	queue[:export].push(image)

	threads << Thread.new do
		sleep 1 while THREADS[:act_export] >= THREADS[:max_export]
		THREADS[:act_export] += 1

		img = queue[:export].shift
		shout( "[#{THREADS[:act_export]}/#{THREADS[:max_export]}] #{img}", "INFO", "EXPORT" )
		snap_name = doExport(options[:backup_pool], img, ceph_args)

                if SNAP_KEEP == 0
                        shout( "removing snapshot #{options[:backup_pool]}/#{img}@#{snap_name}" )
                        `rbd #{ceph_args} snap rm #{options[:backup_pool]}/#{img}@#{snap_name}`
		else
			snaps.push(snap_name)
                end

		THREADS[:act_export] -= 1
		queue[:archive].push("#{img}@#{snap_name}") if ARCH_CMD != ""
	end

	threads << Thread.new do
		sleep 1 while THREADS[:act_archive] >= THREADS[:max_archive] || queue[:archive].empty?

		THREADS[:act_archive] += 1
		snap_file = queue[:archive].shift
		shout( "[#{THREADS[:act_archive]}/#{THREADS[:max_archive]}] #{snap_file}", "INFO", "ARCHIVE" )
		doArchive(snap_file)

                if LOCAL_KEEP == 0
                        shout( "removing local file #{EXPORT_DIR}/#{snap_file}" )
                        File.delete("#{EXPORT_DIR}/#{snap_file}")
                end

		THREADS[:act_archive] -= 1
	end
end

threads.each {|thr| thr.join}


shout("starting rotate process")
images.each do |image, snaps|
	snaps.sort!.reverse!
	## rotate snapshots in cluster
	while snaps.count > SNAP_KEEP && snaps.count != 0
		shout( "removing snapshot: #{image}@#{snaps[snaps.count-1]}" )
		`rbd #{ceph_args} snap rm #{options[:backup_pool]}/#{image}@#{snaps[snaps.count-1]}`
		snaps.delete_at(snaps.count-1)
	end

	## rotate local files
	local_files = Dir["#{EXPORT_DIR}/#{image}@BKP*"].sort!.reverse!
	while local_files.count > LOCAL_KEEP && local_files.count != 0
		shout( "removing local file: #{local_files[local_files.count-1]}" )
		File.delete(local_files[local_files.count-1])
		local_files.delete_at(local_files.count-1)
	end
end
