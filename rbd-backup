#!/usr/bin/ruby
require 'json'
require 'optparse'
require __dir__ + '/lib/color.rb'

## number of snapshots to keep in cluster (0 = delete snapshots after backup)
SNAP_KEEP = 0
## number of exported snapshots to keep in BACKUP_DIR (0 = delete files after backup)
LOCAL_KEEP = 0
## where to export snapshots
BACKUP_DIR = "/home/"
## send snapshots to Tivoli
USE_DSMC = True

options = {}
OptionParser.new do |opts|
	opts.banner = "Usage: rbd-backup [options] pool [image]"

	opts.on("-c", "--config", "Use this configuration file instead of the default") do |c|
		options[:config] = ARGV[0]
	end
	opts.on("-n", "--name", "Client name for authentication") do |n|
		options[:name] = ARGV[0]
	end
end.parse!

options[:backup_pool] = ARGV[ARGV.count-2]
options[:backup_image] = ARGV[ARGV.count-1]

ceph_args = ""
ceph_args = "#{ceph_args} -c #{options[:config]}"	if options[:config] != nil
ceph_args = "#{ceph_args} --name #{options[:name]}"	if options[:name] != nil
images = Hash[]

begin
	pool_exist = `rados #{ceph_args} lspools | grep -c #{options[:backup_pool]} 2>/dev/null`
	if pool_exist == "0"
		puts "no pool with name #{options[:backup_pool]}"
		exit
	end
rescue Exception => e
	puts "Error while get ceph pools: #{e}"
	exit
end

begin
	rbd_images = `rbd #{ceph_args} --format json ls -l #{options[:backup_pool]} 2>/dev/null`
	rbd_images = JSON.parse(rbd_images)
rescue Exception => e
	puts "Error parsing 'ceph ls -l vms' output: #{e}"
	exit
end

rbd_images.each do |rbd_image|
	image_uuid = rbd_image["image"]
	next if image_uuid != options[:backup_image] && options[:backup_image] != nil

	if images[image_uuid] == nil
		## create new hash entry
		images[image_uuid] = Array.new
	end

	## current image has no snapshots
	next if rbd_image["snapshot"] == nil

	if rbd_image["snapshot"] =~ /BKP_([0-9]+\.){2}[0-9]+/
		## found old snapshot
		images[image_uuid].push(rbd_image["snapshot"])
	end
end

if images.length == 0
	if options[:backup_image] != nil
		puts "no image with name #{options[:backup_image]} found"
	else
		puts "no images in pool #{options[:backup_pool]} found" if options[:backup_image]
	end
	exit
end

images.each do |image, snaps|
	puts "processing image #{image}"
	snaps.sort!.reverse!

	## rotate snapshots in cluster
	while snaps.count >= SNAP_KEEP && snaps.count != 0
		puts "rbd rm #{snaps[snaps.count-1]}"
		snaps.delete_at(snaps.count-1)
	end

	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	snap_path = "vms/#{image}@#{snap_name}"

	puts "rbd snap create #{snap_path}"
	puts "rbd export #{snap_path} #{BACKUP_DIR}/#{image}@#{snap_name}"

	if USE_DSMC
		puts "dsmc backup -subdir=yes #{BACKUP_DIR}/#{image}@#{snap_name}"
	end

	## remove latest snapshot if KEEP == 0
	if SNAP_KEEP == 0
		puts "rbd snap rm #{snap_path}"
	end

	## remove local snapshot
	if LOCAL_KEEP == 0
		puts "rm -f #{BACKUP_DIR}/#{image}@#{snap_name}"
	end
end
