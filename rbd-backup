#!/usr/bin/ruby
require 'json'
require 'optparse'
require __dir__ + '/lib/color.rb'

## number of snapshots to keep in cluster (0 = delete snapshots after backup)
SNAP_KEEP = 0
## number of exported snapshots to keep in BACKUP_DIR (0 = delete files after backup)
LOCAL_KEEP = 0
## where to export snapshots
BACKUP_DIR = "/home/"
## send snapshots to Tivoli
USE_DSMC = true
THREADS = Hash["max_export" => 1, "max_archive" => 5]

options = {}
OptionParser.new do |opts|
	opts.banner = "Usage: rbd-backup [options] pool [image]"

	opts.on("-c", "--config", "Use this configuration file instead of the default") do |c|
		options[:config] = ARGV[0]
	end
	opts.on("-n", "--name", "Client name for authentication") do |n|
		options[:name] = ARGV[0]
	end
end.parse!

ARGV.each do |arg|
        ARGV.delete(arg) if options.values.include? arg
end

options[:backup_pool] = ARGV[0]
options[:backup_image] = ARGV[1]

ceph_args = ""
ceph_args = "#{ceph_args} -c #{options[:config]}"	if options[:config] != nil
ceph_args = "#{ceph_args} --name #{options[:name]}"	if options[:name] != nil
images = Hash[]

begin
	pool_exist = `rados #{ceph_args} lspools | grep -c #{options[:backup_pool]} 2>/dev/null`
	if pool_exist.to_i == 0
		puts "no pool with name #{options[:backup_pool]}"
		exit
	end
rescue Exception => e
	puts "Error while get ceph pools: #{e}"
	exit
end

begin
	rbd_images = `rbd #{ceph_args} --format json ls -l #{options[:backup_pool]} 2>/dev/null`
	rbd_images = JSON.parse(rbd_images)
rescue Exception => e
	puts "Error parsing 'ceph ls -l' output: #{e}"
	exit
end

rbd_images.each do |rbd_image|
	image_uuid = rbd_image["image"]
	next if image_uuid != options[:backup_image] && options[:backup_image] != nil

	if images[image_uuid] == nil
		## create new hash entry
		images[image_uuid] = Array.new
	end

	## current image has no snapshots
	next if rbd_image["snapshot"] == nil

	if rbd_image["snapshot"] =~ /BKP_([0-9]+\.){2}[0-9]+/
		## found old snapshot
		images[image_uuid].push(rbd_image["snapshot"])
	end
end

if images.length == 0
	if options[:backup_image] != nil
		puts "no image with name #{options[:backup_image]} found"
	else
		puts "no images in pool #{options[:backup_pool]} found" if options[:backup_image]
	end
	exit
end

def doExport(image)
	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	snap_path = "vms/#{image}@#{snap_name}"

	#puts "rbd snap create #{snap_path}"
	#puts "[#{act_export_threads}/#{max_export_threads}] rbd export #{snap_path} #{BACKUP_DIR}/#{image}@#{snap_name}"
	sleep 20
	return snap_name
end

def doArchive(image)
	snap_date = Time.now().strftime("%Y.%m.%d")
	snap_name = "BKP_#{snap_date}"
	#puts "[#{act_dsm_threads}/#{max_dsm_threads}] dsmc backup -subdir=yes #{BACKUP_DIR}/#{image}@#{snap_name}"
	sleep 120
end

threads = []
queue = Hash[:export => Array.new, :archive => Array.new]
THREADS[:act_export] = 0
THREADS[:act_archive] = 0

images.each do |image, snaps|
#	snaps.sort!.reverse!

	## rotate snapshots in cluster
#	while snaps.count >= SNAP_KEEP && snaps.count != 0
#		puts "rbd rm #{snaps[snaps.count-1]}"
#		snaps.delete_at(snaps.count-1)
#	end
	queue[:export].push(image)

	threads << Thread.new do
		sleep 1 while THREADS[:act_export] >= THREADS[:max_export]
		THREADS[:act_export] += 1

		img = queue[:export].shift
		puts "[#{act_export_threads}/#{max_export_threads}] => EXPORT: #{img}"
		snap = doExport(img)
		snaps.push(snap)
		THREADS[:act_export] -= 1
		queue[:archive].push(img) if USE_DSMC
	end

	sleep 1 while queue[:archive].empty?

	threads << Thread.new do
		sleep 1 while THREADS[:act_archive] >= THREADS[:max_archive]

		THREADS[:act_archive] += 1
		img = queue[:archive].shift
		puts "[#{act_dsm_threads}/#{max_dsm_threads}] => ARCHIVE: #{img}"
		doArchive(img)
		THREADS[:act_archive] -= 1
	end

	## remove latest snapshot if KEEP == 0
#	if SNAP_KEEP == 0
#		puts "rbd snap rm #{snap_path}"
#	end

	## remove local snapshot
#	if LOCAL_KEEP == 0
#		puts "rm -f #{BACKUP_DIR}/#{image}@#{snap_name}"
#	end
end

threads.each {|thr| thr.join}

images.each do |image, snaps|
	snaps.sort!.reverse!
	## rotate snapshots in cluster
	while snaps.count >= SNAP_KEEP && snaps.count != 0
		puts "rbd rm #{snaps[snaps.count-1]}"
		snaps.delete_at(snaps.count-1)
	end
end
